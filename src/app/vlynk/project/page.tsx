'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import Header from '@/app/components/Header';
import { io, Socket } from 'socket.io-client';
import WaveformCanvas from './components/WaveformCanvas';
import styles from './project.module.css';

interface MusicRoom {
  id: string;
  name: string;
  userCount: number;
  maxUsers: number;
  hasPassword: boolean;
  creator: string;
  description: string;
  tech: string[];
  status: 'active' | 'inactive';
}

interface Track {
  originalName: string;
  filename: string;
  url: string;
  uploader: string;
  uploadedAt?: string;
  file?: File;
}

interface Comment {
  id: string;
  user: string;
  message: string;
  timestamp: number;
  time: string;
  type?: 'text' | 'voice';
  voiceUrl?: string;
}

interface User {
  id: string;
  username: string;
  role: 'ADMIN' | 'MEMBER';
  namespace: 'project';
}

export default function ProjectPage() {
  // ===== Socket & Connection State =====
  const [socket, setSocket] = useState<Socket | null>(null);
  const [connectionStatus, setConnectionStatus] = useState('Ïó∞Í≤∞ Ï§ë...');
  const [connectedUsers, setConnectedUsers] = useState<number>(0);
  
  // ===== User State =====
  const [currentUser, setCurrentUser] = useState<User>({ id: '', username: '', role: 'MEMBER', namespace: 'project' });
  const [username, setUsername] = useState('');
  const [showLogin, setShowLogin] = useState(true);
  
  // ===== Music Room State =====
  const [musicRooms, setMusicRooms] = useState<MusicRoom[]>([]);
  const [currentMusicRoom, setCurrentMusicRoom] = useState<MusicRoom | null>(null);
  const [showMusicRoom, setShowMusicRoom] = useState(false);
  
  // ===== Audio State =====
  const [currentTrack, setCurrentTrack] = useState<Track | null>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [totalTime, setTotalTime] = useState(0);
  const [commentTime, setCommentTime] = useState(0);
  
  // ===== Comments State =====
  const [comments, setComments] = useState<Comment[]>([]);
  const [newComment, setNewComment] = useState('');
  
  // ===== Voice Recording State =====
  const [isRecording, setIsRecording] = useState(false);
  const [mediaRecorder, setMediaRecorder] = useState<MediaRecorder | null>(null);
  
  // ===== Refs =====
  const audioRef = useRef<HTMLAudioElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // ===== Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§ =====
  const formatTime = (seconds: number): string => {
    if (!seconds || isNaN(seconds) || !isFinite(seconds)) {
      return '00:00';
    }
    
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  const handleSeek = useCallback((time: number) => {
    if (!audioRef.current || !currentTrack) return;
    
    const audio = audioRef.current;
    
    // ÏãúÍ∞Ñ Í∞í Í≤ÄÏ¶ù
    if (isNaN(time) || time < 0) {
      console.warn('‚ö†Ô∏è Invalid seek time:', time);
      return;
    }
    
    // duration Ï≤¥ÌÅ¨
    if (!audio.duration || isNaN(audio.duration) || audio.duration <= 0) {
      console.warn('‚ö†Ô∏è Cannot seek: invalid duration');
      return;
    }
    
    // ÏµúÎåÄ ÏãúÍ∞Ñ Ï†úÌïú
    const seekTime = Math.min(time, audio.duration - 0.1);
    
    console.log('üéµ Seeking to:', seekTime);
    audio.currentTime = seekTime;
    setCurrentTime(seekTime);
  }, [currentTrack]);

  // ===== Socket Ïó∞Í≤∞ Î∞è Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨ =====
  useEffect(() => {
    const newSocket = io('http://localhost:3001/project', {
      transports: ['websocket', 'polling'],
      timeout: 10000,
      forceNew: true
    });

    newSocket.on('connect', () => {
      console.log('üîå Project Socket connected:', newSocket.id);
      setSocket(newSocket);
      setConnectionStatus('Ïó∞Í≤∞Îê®');
    });

    newSocket.on('disconnect', (reason) => {
      console.log('üîå Project Socket disconnected:', reason);
      setConnectionStatus('Ïó∞Í≤∞ ÎÅäÏñ¥Ïßê');
    });

    newSocket.on('connect_error', (error) => {
      console.error('üîå Project Socket connection error:', error);
      setConnectionStatus('Ïó∞Í≤∞ Ïã§Ìå®');
    });

    // ÏÇ¨Ïö©Ïûê Î°úÍ∑∏Ïù∏ ÏùëÎãµ - ÏÑúÎ≤ÑÏôÄ ÎèôÏùºÌïú Ïù¥Î≤§Ìä∏Î™Ö ÏÇ¨Ïö©
    newSocket.on('user:login_success', (data) => {
      console.log('üë§ Login successful:', data);
      setCurrentUser(data.user);
      setConnectedUsers(data.connectedUsers);
      setShowLogin(false);
    });

    newSocket.on('user:login_error', (error) => {
      console.error('üë§ Login failed:', error);
      alert('Î°úÍ∑∏Ïù∏ Ïã§Ìå®: ' + error.message);
    });

    // Ïó∞Í≤∞Îêú ÏÇ¨Ïö©Ïûê Ïàò ÏóÖÎç∞Ïù¥Ìä∏ - Ïù¥ÎØ∏ login_successÏóêÏÑú Î∞õÏúºÎØÄÎ°ú Ï†úÍ±∞ÌïòÍ±∞ÎÇò Î≥ÑÎèÑ Ï≤òÎ¶¨
    // newSocket.on('users:count', (count) => {
    //   setConnectedUsers(count);
    // });

    // ÏùåÏïÖÎ∞© Î™©Î°ù ÏóÖÎç∞Ïù¥Ìä∏ - ÏÑúÎ≤ÑÏôÄ ÎèôÏùºÌïú Ïù¥Î≤§Ìä∏Î™Ö ÏÇ¨Ïö©  
    newSocket.on('rooms:list', (rooms) => {
      console.log('üéµ Music rooms received:', rooms);
      // Ï§ëÎ≥µ Ï†úÍ±∞Î•º ÏúÑÌï¥ Map ÏÇ¨Ïö©
      const uniqueRooms = rooms.reduce((acc: MusicRoom[], room: MusicRoom) => {
        const existing = acc.find(r => r.id === room.id);
        if (!existing) {
          acc.push(room);
        }
        return acc;
      }, []);
      setMusicRooms(uniqueRooms);
    });

    // ÏùåÏïÖÎ∞© ÏÉùÏÑ± ÏÑ±Í≥µ - ÏÑúÎ≤ÑÏôÄ ÎèôÏùºÌïú Ïù¥Î≤§Ìä∏Î™Ö ÏÇ¨Ïö©
    newSocket.on('room:created', (data) => {
      console.log('üéµ Room created:', data.room);
      // Ï§ëÎ≥µ Î∞©ÏßÄ: Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî Î£∏Ïù∏ÏßÄ ÌôïÏù∏ ÌõÑ Ï∂îÍ∞Ä
      setMusicRooms(prev => {
        const existingRoom = prev.find(room => room.id === data.room.id);
        if (existingRoom) {
          console.log('üîÑ Room already exists, updating...');
          return prev.map(room => 
            room.id === data.room.id ? data.room : room
          );
        } else {
          console.log('‚ûï Adding new room...');
          return [...prev, data.room];
        }
      });
    });

    // ÏùåÏïÖÎ∞© ÏûÖÏû• ÏÑ±Í≥µ - ÏÑúÎ≤ÑÏôÄ ÎèôÏùºÌïú Ïù¥Î≤§Ìä∏Î™Ö ÏÇ¨Ïö©
    newSocket.on('music:room_joined', (data) => {
      console.log('üéµ Joined music room:', data.room);
      setCurrentMusicRoom(data.room);
      setComments(data.comments || []);
      setShowMusicRoom(true);
    });

    // Ìä∏Îûô ÏóÖÎ°úÎìú ÏÑ±Í≥µ
    newSocket.on('music uploaded', (data) => {
      console.log('üéµ Track uploaded:', data);
      // Ïù¥ÎØ∏ Î°úÏª¨ÏóêÏÑú Ìä∏ÎûôÏùÑ ÏÑ§Ï†ïÌñàÏúºÎØÄÎ°ú Ï∂îÍ∞Ä ÏûëÏóÖ ÏóÜÏùå
    });

    // ÎåìÍ∏Ä Ïù¥Î≤§Ìä∏ - Ï§ëÎ≥µ Î∞©ÏßÄ Î°úÏßÅ Ï∂îÍ∞Ä
    newSocket.on('music chat message', (messageData) => {
      console.log('üí¨ New chat message received:', messageData);
      
      const comment: Comment = {
        id: messageData.id || Date.now().toString(),
        user: messageData.user || messageData.username,
        message: messageData.message,
        timestamp: messageData.timestamp || 0,
        time: messageData.time || new Date().toLocaleTimeString(),
        type: messageData.type || 'text'
      };
      
      console.log('üìù Adding comment to UI:', comment);
      setComments(prev => {
        // ÏûÑÏãú ÎåìÍ∏Ä(ÎÇôÍ¥ÄÏ†Å ÏóÖÎç∞Ïù¥Ìä∏) Ï†úÍ±∞
        const withoutTemp = prev.filter(existing => !existing.id.startsWith('temp_'));
        
        // Ï§ëÎ≥µ ÌôïÏù∏: Í∞ôÏùÄ Î©îÏãúÏßÄÏôÄ ÏÇ¨Ïö©Ïûê, ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑÍ∞Ä ÏûàÎäîÏßÄ Ï≤¥ÌÅ¨
        const isDuplicate = withoutTemp.some(existing => 
          existing.message === comment.message && 
          existing.user === comment.user &&
          Math.abs(existing.timestamp - comment.timestamp) < 1 // 1Ï¥à Ïù¥ÎÇ¥ Í∞ôÏùÄ Î©îÏãúÏßÄÎäî Ï§ëÎ≥µÏúºÎ°ú Í∞ÑÏ£º
        );
        
        if (isDuplicate) {
          console.log('üîÑ Duplicate comment detected, skipping...');
          return withoutTemp;
        }
        
        const updated = [...withoutTemp, comment];
        console.log('üìã Updated comments list:', updated.length);
        return updated;
      });
    });

    // Ï†ïÎ¶¨
    return () => {
      newSocket.disconnect();
    };
  }, []); // currentMusicRoom?.id Ï†úÍ±∞

  // ===== ÏàòÏ†ïÎêú Ïò§ÎîîÏò§ Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨Îì§ =====
  useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;

    const handleTimeUpdate = () => {
      if (!isNaN(audio.currentTime)) {
        const newTime = audio.currentTime;
        console.log('‚è∞ Time update:', newTime, '/', audio.duration);
        setCurrentTime(newTime);
        setCommentTime(newTime);
      } else {
        console.warn('‚ö†Ô∏è Invalid currentTime:', audio.currentTime);
      }
    };

    const handleLoadedMetadata = () => {
      console.log('üéµ Metadata loaded - Duration:', audio.duration);
      if (audio.duration && !isNaN(audio.duration) && isFinite(audio.duration) && audio.duration > 0) {
        setTotalTime(audio.duration);
        console.log('‚úÖ Total time set:', audio.duration);
      } else {
        console.warn('‚ö†Ô∏è Invalid duration:', audio.duration);
        // Ïû¨ÏãúÎèÑ Î°úÏßÅ
        setTimeout(() => {
          if (audio.duration && !isNaN(audio.duration) && isFinite(audio.duration) && audio.duration > 0) {
            setTotalTime(audio.duration);
            console.log('üîÑ Retry - Total time set:', audio.duration);
          }
        }, 100);
      }
    };

    const handleLoadedData = () => {
      console.log('üéµ Audio data loaded');
      // loadedmetadataÍ∞Ä Ïïà Îê† Í≤ΩÏö∞ ÎåÄÏïà
      if (audio.duration && !isNaN(audio.duration) && isFinite(audio.duration) && audio.duration > 0) {
        setTotalTime(audio.duration);
        console.log('üìä Duration from loadeddata:', audio.duration);
      }
    };

    const handleCanPlay = () => {
      console.log('üéµ Can play - Duration:', audio.duration);
      if (audio.duration && !isNaN(audio.duration) && isFinite(audio.duration) && audio.duration > 0) {
        setTotalTime(audio.duration);
      }
    };

    const handleEnded = () => {
      console.log('üéµ Audio ended');
      setIsPlaying(false);
    };
    
    const handlePause = () => {
      console.log('üéµ Audio paused');
      setIsPlaying(false);
    };
    
    const handlePlay = () => {
      console.log('üéµ Audio playing');
      setIsPlaying(true);
    };

    const handleError = (e: Event) => {
      console.error('‚ùå Audio error:', e);
      setIsPlaying(false);
      if (audio.error) {
        let errorMsg = '';
        switch(audio.error.code) {
          case MediaError.MEDIA_ERR_ABORTED:
            errorMsg = 'Ïû¨ÏÉùÏù¥ Ï§ëÎã®ÎêòÏóàÏäµÎãàÎã§';
            break;
          case MediaError.MEDIA_ERR_NETWORK:
            errorMsg = 'ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò';
            break;
          case MediaError.MEDIA_ERR_DECODE:
            errorMsg = 'ÎîîÏΩîÎî© Ïò§Î•ò';
            break;
          case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
            errorMsg = 'ÏßÄÏõêÌïòÏßÄ ÏïäÎäî ÌååÏùº ÌòïÏãù';
            break;
          default:
            errorMsg = 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò';
        }
        alert(`Ïò§ÎîîÏò§ Î°úÎî© Ïã§Ìå®: ${errorMsg}`);
      }
    };

    const handleWaiting = () => {
      console.log('üéµ Audio waiting/buffering');
    };

    // Î™®Îì† Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ù
    audio.addEventListener('timeupdate', handleTimeUpdate);
    audio.addEventListener('loadedmetadata', handleLoadedMetadata);
    audio.addEventListener('loadeddata', handleLoadedData);
    audio.addEventListener('canplay', handleCanPlay);
    audio.addEventListener('ended', handleEnded);
    audio.addEventListener('pause', handlePause);
    audio.addEventListener('play', handlePlay);
    audio.addEventListener('error', handleError);
    audio.addEventListener('waiting', handleWaiting);

    return () => {
      audio.removeEventListener('timeupdate', handleTimeUpdate);
      audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
      audio.removeEventListener('loadeddata', handleLoadedData);
      audio.removeEventListener('canplay', handleCanPlay);
      audio.removeEventListener('ended', handleEnded);
      audio.removeEventListener('pause', handlePause);
      audio.removeEventListener('play', handlePlay);
      audio.removeEventListener('error', handleError);
      audio.removeEventListener('waiting', handleWaiting);
    };
  }, [currentTrack]); // currentTrack ÏùòÏ°¥ÏÑ± Ï∂îÍ∞Ä

  // ===== Ìï∏Îì§Îü¨ Ìï®ÏàòÎì§ =====
  const handleLogin = () => {
    if (!username.trim() || !socket) return;
    
    console.log('üë§ Attempting login with username:', username);
    socket.emit('user:login', { 
      username: username.trim(), 
      namespace: 'project' 
    });
  };

  const createMusicRoom = () => {
    if (!socket) return;
    
    const roomName = prompt('ÏùåÏïÖÎ∞© Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî:');
    if (!roomName) return;
    
    socket.emit('room:create', {
      name: roomName,
      description: 'ÏÉàÎ°úÏö¥ ÏùåÏïÖ ÏûëÏóÖ Í≥µÍ∞ÑÏûÖÎãàÎã§.',
      maxUsers: 10,
      hasPassword: false
    });
  };

  const joinMusicRoom = (roomId: string) => {
    if (!socket) return;
    
    console.log('üéµ Joining music room:', roomId);
    socket.emit('room:join', { roomId });
  };

  const leaveMusicRoom = () => {
    if (!socket || !currentMusicRoom) return;
    
    console.log('üéµ Leaving music room');
    socket.emit('room:leave');
    setShowMusicRoom(false);
    setCurrentMusicRoom(null);
    setCurrentTrack(null);
    setComments([]);
    setIsPlaying(false);
    setCurrentTime(0);
    setTotalTime(0);
  };

  // ===== ÏàòÏ†ïÎêú Ïû¨ÏÉù/ÏùºÏãúÏ†ïÏßÄ ÌÜ†Í∏Ä Ìï®Ïàò =====
  const togglePlayback = async () => {
    if (!audioRef.current || !currentTrack) {
      console.warn('‚ö†Ô∏è No audio or track available');
      return;
    }

    const audio = audioRef.current;
    
    try {
      console.log('üéµ Toggle playback - Current state:', { isPlaying, paused: audio.paused, readyState: audio.readyState });
      
      if (isPlaying || !audio.paused) {
        console.log('üéµ Pausing audio');
        audio.pause();
        setIsPlaying(false); // Î™ÖÏãúÏ†ÅÏúºÎ°ú ÏÉÅÌÉú ÏÑ§Ï†ï
        // Í∞ïÏ†ú ÏãúÍ∞Ñ Ï∂îÏ†Å Ï§ëÎã®ÏùÑ ÏúÑÌï¥ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        console.log('‚è∏Ô∏è Playback paused');
      } else {
        console.log('üéµ Attempting to play audio');
        
        // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Í∞Ä ÏïÑÏßÅ Î°úÎìúÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ Ïû¨ÏãúÎèÑ
        if (!audio.duration || isNaN(audio.duration) || audio.duration === 0) {
          console.log('üéµ Metadata not ready, reloading...');
          audio.load();
          
          // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎî© ÎåÄÍ∏∞
          await new Promise<void>((resolve, reject) => {
            const onLoadedMetadata = () => {
              console.log('üéµ Retry - Metadata loaded:', audio.duration);
              audio.removeEventListener('loadedmetadata', onLoadedMetadata);
              audio.removeEventListener('error', onError);
              resolve();
            };
            
            const onError = () => {
              console.error('üéµ Retry - Load error');
              audio.removeEventListener('loadedmetadata', onLoadedMetadata);
              audio.removeEventListener('error', onError);
              reject(new Error('Audio reload failed'));
            };
            
            audio.addEventListener('loadedmetadata', onLoadedMetadata);
            audio.addEventListener('error', onError);
            
            // Ïù¥ÎØ∏ Î°úÎìúÎêú Í≤ΩÏö∞
            if (audio.readyState >= 1 && audio.duration > 0) {
              onLoadedMetadata();
            }
            
            // 2Ï¥à ÌÉÄÏûÑÏïÑÏõÉ
            setTimeout(() => {
              audio.removeEventListener('loadedmetadata', onLoadedMetadata);
              audio.removeEventListener('error', onError);
              reject(new Error('Metadata load timeout'));
            }, 2000);
          });
        }
        
        await audio.play();
        setIsPlaying(true); // Î™ÖÏãúÏ†ÅÏúºÎ°ú ÏÉÅÌÉú ÏÑ§Ï†ï
        console.log('‚úÖ Audio playing successfully');
        
        // Ïû¨ÏÉù ÏãúÏûë ÌõÑ Í∞ïÏ†ú ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë
        const startTimeTracking = () => {
          if (audioRef.current && !audioRef.current.paused) {
            const current = audioRef.current.currentTime;
            console.log('üîÑ Force time update:', current);
            setCurrentTime(current);
            setCommentTime(current);
            setTimeout(startTimeTracking, 100); // 100msÎßàÎã§ ÏóÖÎç∞Ïù¥Ìä∏
          }
        };
        setTimeout(startTimeTracking, 100);
      }
    } catch (error: any) {
      console.error('Ïû¨ÏÉù Ïò§Î•ò:', error);
      setIsPlaying(false);
      
      // ÏÇ¨Ïö©Ïûê ÏπúÌôîÏ†Å Ïò§Î•ò Î©îÏãúÏßÄ
      if (error.name === 'NotAllowedError') {
        alert('Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú ÏûêÎèô Ïû¨ÏÉùÏù¥ Ï∞®Îã®ÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú ÌÅ¥Î¶≠Ìï¥Ï£ºÏÑ∏Ïöî.');
      } else if (error.name === 'NotSupportedError') {
        alert('ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Ïò§ÎîîÏò§ ÌòïÏãùÏûÖÎãàÎã§.');
      } else {
        alert('Ïû¨ÏÉù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. ÌååÏùºÏùÑ Îã§Ïãú ÏóÖÎ°úÎìúÌï¥Ï£ºÏÑ∏Ïöî.');
      }
    }
  };

  // ===== ÏàòÏ†ïÎêú ÌååÏùº ÏóÖÎ°úÎìú Ìï∏Îì§Îü¨ =====
  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file || !socket || !currentMusicRoom) return;

    if (!file.type.startsWith('audio/')) {
      alert('Ïò§ÎîîÏò§ ÌååÏùºÎßå ÏóÖÎ°úÎìú Í∞ÄÎä•Ìï©ÎãàÎã§.');
      return;
    }

    if (file.size > 50 * 1024 * 1024) {
      alert('ÌååÏùº ÌÅ¨Í∏∞Îäî 50MBÎ•º Ï¥àÍ≥ºÌï† Ïàò ÏóÜÏäµÎãàÎã§.');
      return;
    }

    try {
      console.log('üéµ Uploading file:', file.name);
      
      // Ïù¥Ï†Ñ Ïò§ÎîîÏò§ Ï†ïÎ¶¨
      if (audioRef.current) {
        audioRef.current.pause();
        audioRef.current.src = '';
        audioRef.current.load(); // Ïù¥Ï†Ñ Î°úÎìúÎêú ÎÇ¥Ïö© Ï¥àÍ∏∞Ìôî
      }

      // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      setIsPlaying(false);
      setCurrentTime(0);
      setTotalTime(0);
      
      // Ìä∏Îûô Ï†ïÎ≥¥ ÏÉùÏÑ±
      const track: Track = {
        originalName: file.name,
        filename: file.name,
        url: URL.createObjectURL(file),
        uploader: currentUser.username,
        uploadedAt: new Date().toISOString(),
        file: file
      };

      console.log('üéµ Track created:', track);
      setCurrentTrack(track);

      // Ïò§ÎîîÏò§ ÏóòÎ¶¨Î®ºÌä∏Ïóê ÌååÏùº Î°úÎìú
      if (audioRef.current) {
        audioRef.current.src = track.url;
        audioRef.current.load(); // Î™ÖÏãúÏ†ÅÏúºÎ°ú Î°úÎìú Ìò∏Ï∂ú
        
        // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎî©ÏùÑ Í∏∞Îã§Î¶¨Îäî Promise
        const loadPromise = new Promise<void>((resolve, reject) => {
          const audio = audioRef.current!;
          
          const onLoadedMetadata = () => {
            console.log('üéµ Promise - Metadata loaded:', audio.duration);
            if (audio.duration && !isNaN(audio.duration) && isFinite(audio.duration) && audio.duration > 0) {
              setTotalTime(audio.duration);
            }
            audio.removeEventListener('loadedmetadata', onLoadedMetadata);
            audio.removeEventListener('error', onError);
            resolve();
          };
          
          const onError = () => {
            console.error('üéµ Promise - Load error');
            audio.removeEventListener('loadedmetadata', onLoadedMetadata);
            audio.removeEventListener('error', onError);
            reject(new Error('Audio load failed'));
          };
          
          audio.addEventListener('loadedmetadata', onLoadedMetadata);
          audio.addEventListener('error', onError);
          
          // Ïù¥ÎØ∏ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Í∞Ä Î°úÎìúÎêú Í≤ΩÏö∞
          if (audio.readyState >= 1) {
            onLoadedMetadata();
          }
        });

        // ÏµúÎåÄ 3Ï¥à ÎåÄÍ∏∞
        try {
          await Promise.race([
            loadPromise,
            new Promise((_, reject) => 
              setTimeout(() => reject(new Error('Timeout')), 3000)
            )
          ]);
          console.log('‚úÖ Audio metadata loaded successfully');
          
          // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎî© ÌõÑ Í∞ïÏ†úÎ°ú ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë
          const testTimeUpdate = () => {
            if (audioRef.current) {
              const audio = audioRef.current;
              console.log('üß™ Test time update:', {
                currentTime: audio.currentTime,
                duration: audio.duration,
                paused: audio.paused,
                readyState: audio.readyState
              });
              setCurrentTime(audio.currentTime);
              if (!audio.paused) {
                setTimeout(testTimeUpdate, 100); // 100msÎßàÎã§ Ï≤¥ÌÅ¨
              }
            }
          };
          
          // timeupdate Ïù¥Î≤§Ìä∏Í∞Ä ÏûëÎèôÌïòÏßÄ ÏïäÏùÑ Í≤ΩÏö∞Î•º ÏúÑÌïú Ìè¥Î∞±
          setTimeout(testTimeUpdate, 100);
          
        } catch (error) {
          console.warn('‚ö†Ô∏è Audio metadata loading timeout or failed:', error);
          // Ïã§Ìå®Ìï¥ÎèÑ Í≥ÑÏÜç ÏßÑÌñâ (ÏùºÎ∂Ä Î∏åÎùºÏö∞Ï†ÄÏóêÏÑúÎäî Ïû¨ÏÉù ÏãúÏ†êÏóê Î°úÎìúÎê®)
        }
      }
      
      // ÏÑúÎ≤ÑÏóê ÏïåÎ¶º (Ïã§Ï†ú ÌååÏùº ÏóÖÎ°úÎìúÎäî ÏÉùÎûµ)
      socket.emit('music uploaded', {
        roomId: currentMusicRoom.id,
        musicData: {
          originalname: track.originalName,
          filename: track.filename,
          url: track.url
        }
      });

    } catch (error) {
      console.error('ÌååÏùº ÏóÖÎ°úÎìú Ïò§Î•ò:', error);
      alert('ÌååÏùº ÏóÖÎ°úÎìú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
      
      // Ïò§Î•ò Ïãú ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      setCurrentTrack(null);
      setIsPlaying(false);
      setCurrentTime(0);
      setTotalTime(0);
    }
  };

  const sendComment = () => {
    if (!newComment.trim() || !socket || !currentMusicRoom || !currentUser) return;

    const commentData = {
      roomId: currentMusicRoom.id,
      message: newComment.trim(),
      timestamp: commentTime,
      time: formatTime(commentTime)
    };

    console.log('üí¨ Sending comment:', commentData);
    
    // ÏÑúÎ≤ÑÏóê Ï†ÑÏÜ° (ÎÇôÍ¥ÄÏ†Å ÏóÖÎç∞Ïù¥Ìä∏ Ï†úÍ±∞)
    socket.emit('music chat message', commentData);
    setNewComment('');
  };

  const startVoiceRecording = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const recorder = new MediaRecorder(stream);
      const chunks: Blob[] = [];

      recorder.ondataavailable = (e) => chunks.push(e.data);
      recorder.onstop = () => {
        const blob = new Blob(chunks, { type: 'audio/wav' });
        // TODO: ÏùåÏÑ± Î©îÏãúÏßÄ ÏóÖÎ°úÎìú Î∞è Ï†ÑÏÜ° Î°úÏßÅ
        stream.getTracks().forEach(track => track.stop());
      };

      recorder.start();
      setMediaRecorder(recorder);
      setIsRecording(true);

      setTimeout(() => {
        if (recorder.state === 'recording') {
          recorder.stop();
          setIsRecording(false);
          setMediaRecorder(null);
        }
      }, 30000); // 30Ï¥à Ï†úÌïú

    } catch (error) {
      console.error('ÏùåÏÑ± ÎÖπÏùå Ïò§Î•ò:', error);
      alert('ÎßàÏù¥ÌÅ¨ Ï†ëÍ∑ºÏù¥ Í±∞Î∂ÄÎêòÏóàÏäµÎãàÎã§.');
    }
  };

  const stopVoiceRecording = () => {
    if (mediaRecorder && mediaRecorder.state === 'recording') {
      mediaRecorder.stop();
      setIsRecording(false);
      setMediaRecorder(null);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      if (showLogin) {
        handleLogin();
      } else {
        sendComment();
      }
    }
  };

  const handleCommentKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendComment();
    }
  };

  // ===== Î†åÎçîÎßÅ =====

  // Î°úÍ∑∏Ïù∏ ÌôîÎ©¥
  if (showLogin) {
    return (
      <div className={styles.container}>
        <Header />
        
        <div className={styles.userInfo}>
          USER: GUEST
          <span className={styles.userRole}>[GUEST]</span>
        </div>

        <div className={styles.loginOverlay}>
          <div className={styles.loginBox}>
            <div className={styles.loginTitle}>MUSIC PROJECT ACCESS</div>
            <div className={styles.loginSubtext}>ENTER USERNAME</div>
            <input
              type="text"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              placeholder="USERNAME"
              className={styles.loginInput}
              maxLength={20}
              onKeyPress={handleKeyPress}
              autoFocus
            />
            <button
              onClick={handleLogin}
              disabled={!username.trim()}
              className={styles.loginBtn}
            >
              ENTER STUDIO
            </button>
            <div className={styles.connectionStatus}>
              STATUS: <span className={connectionStatus === 'Ïó∞Í≤∞Îê®' ? styles.connected : styles.disconnected}>
                {connectionStatus}
              </span>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // ÏùåÏïÖÎ∞© ÌôîÎ©¥
  if (showMusicRoom && currentMusicRoom) {
    return (
      <div className={styles.musicRoom}>
        <Header />
        
        {/* Ïà®Í≤®ÏßÑ Ïò§ÎîîÏò§ ÏóòÎ¶¨Î®ºÌä∏ */}
        <audio ref={audioRef} preload="metadata" />
        <input
          ref={fileInputRef}
          type="file"
          accept="audio/*"
          style={{ display: 'none' }}
          onChange={handleFileUpload}
        />

        {/* ÏùåÏïÖÎ∞© Ìó§Îçî */}
        <div className={styles.musicRoomHeader}>
          <div className={styles.roomTitle}>
            üéµ {currentMusicRoom.name}
          </div>
          <button onClick={leaveMusicRoom} className={styles.leaveBtn}>
            LEAVE STUDIO
          </button>
        </div>

        {/* ÏùåÏïÖÎ∞© ÏΩòÌÖêÏ∏† */}
        <div className={styles.musicContent}>
          {/* Ìä∏Îûô Ìó§Îçî */}
          <div className={styles.trackHeaderSimple}>
            <div className={styles.trackInfoLeft}>
              <div className={styles.trackTitleSimple}>
                {currentTrack ? currentTrack.originalName : 'No track selected'}
              </div>
              <div className={styles.trackUploaderSimple}>
                {currentTrack ? `Uploaded by ${currentTrack.uploader}` : 'Upload a track to get started'}
              </div>
            </div>
            <div className={styles.trackActions}>
              <button 
                className={styles.downloadBtn} 
                disabled={!currentTrack}
              >
                üíæ DOWNLOAD
              </button>
            </div>
          </div>

          {/* Ïõ®Ïù¥Î∏åÌèº ÏòÅÏó≠ */}
          <div className={styles.waveformMainArea}>
            <div className={styles.waveformContainerMain}>
              <WaveformCanvas
                audioFile={currentTrack?.file || null}
                isPlaying={isPlaying}
                currentTime={currentTime}
                totalTime={totalTime}
                onSeek={handleSeek}
                className={styles.waveformCanvasMain}
              />
              
              {!currentTrack && (
                <div className={styles.waveformLoadingMain}>
                  üéµ Upload a track to see waveform<br/>
                  Drag and drop or click upload button
                </div>
              )}
            </div>

            {/* ÏãúÍ∞Ñ ÌëúÏãú */}
            <div className={styles.timeDisplay}>
              <span className={styles.timeCurrent}>{formatTime(currentTime)}</span>
              <span className={styles.timeSeparator}>/</span>
              <span className={styles.timeTotal}>{formatTime(totalTime)}</span>
              {/* ÎîîÎ≤ÑÍπÖÏö© Ï†ïÎ≥¥ - Í∞úÎ∞ú ÏôÑÎ£å ÌõÑ Ï†úÍ±∞ */}
              <div style={{ fontSize: '6px', color: '#666', marginTop: '5px' }}>
                Debug: isPlaying={isPlaying ? 'true' : 'false'}, 
                hasTrack={currentTrack ? 'yes' : 'no'}, 
                audioSrc={audioRef.current?.src ? 'set' : 'none'},
                comments={comments.length}
              </div>
            </div>

            {/* Ïª®Ìä∏Î°§ Î≤ÑÌäºÎì§ */}
            <div className={styles.simpleControls}>
              <button 
                onClick={togglePlayback}
                disabled={!currentTrack}
                className={styles.playBtnMain}
              >
                {isPlaying ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'}
              </button>
              <button 
                onClick={() => fileInputRef.current?.click()}
                className={styles.uploadBtnMain}
              >
                üéµ UPLOAD MUSIC
              </button>
            </div>
          </div>

          {/* ÎåìÍ∏Ä ÏÑπÏÖò */}
          <div className={styles.commentsSection}>
            <div className={styles.commentInputArea}>
              <div className={styles.commentTimeIndicator}>
                {formatTime(commentTime)}
              </div>
              <input
                type="text"
                value={newComment}
                onChange={(e) => setNewComment(e.target.value)}
                placeholder="Add your comment here, mention users with @"
                className={styles.commentInput}
                onKeyPress={handleKeyPress}
              />
              <button 
                onClick={isRecording ? stopVoiceRecording : startVoiceRecording}
                className={`${styles.commentBtn} ${styles.voice} ${isRecording ? styles.recording : ''}`}
              >
                üé§ {isRecording ? 'RECORDING' : 'VOICE'}
              </button>
              <button 
                onClick={sendComment}
                disabled={!newComment.trim()}
                className={`${styles.commentBtn} ${styles.send}`}
              >
                SEND
              </button>
            </div>

            <div className={styles.commentsList}>
              {comments.map((comment) => (
                <div key={comment.id} className={styles.commentItem}>
                  <div className={styles.commentHeader}>
                    <span className={styles.commentUser}>{comment.user}</span>
                    <span 
                      className={styles.commentTimestamp}
                      onClick={() => handleSeek(comment.timestamp)}
                    >
                      [{formatTime(comment.timestamp)}]
                    </span>
                  </div>
                  <div className={styles.commentMessage}>
                    {comment.type === 'voice' ? (
                      <div className={styles.voiceMessage}>
                        üé§ Voice Message
                        {comment.voiceUrl && (
                          <audio controls>
                            <source src={comment.voiceUrl} type="audio/wav" />
                          </audio>
                        )}
                      </div>
                    ) : (
                      comment.message
                    )}
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Î©îÏù∏ ÏùåÏïÖÎ∞© Î™©Î°ù ÌôîÎ©¥
  return (
    <div className={styles.container}>
      <Header />
      
      <div className={styles.userInfo}>
        USER: <span>{currentUser.username}</span>
        <span className={styles.userRole}>[{currentUser.role}]</span>
      </div>

      <div className={styles.mainContainer}>
        <div className={styles.header}>
          <h1>VVCKD MUSIC STUDIO <span className={styles.cursor}>‚ñå</span></h1>
          <div className={styles.statusText}>
            Connected Users: {connectedUsers}<br/>
            Status: <span className={connectionStatus === 'Ïó∞Í≤∞Îê®' ? styles.connected : styles.disconnected}>
              {connectionStatus}
            </span>
          </div>
        </div>

        <div className={styles.createRoomSection}>
          <button onClick={createMusicRoom} className={styles.createRoomBtn}>
            CREATE MUSIC ROOM
          </button>
        </div>

        <div className={styles.roomsGrid}>
          {musicRooms.length === 0 ? (
            <div className={styles.noRooms}>
              <p>No music rooms available</p>
              <p>Create a room to start collaborating!</p>
            </div>
          ) : (
            // Ï§ëÎ≥µ Ï†úÍ±∞Î•º ÏúÑÌïú Ï∂îÍ∞Ä ÌïÑÌÑ∞ÎßÅ
            musicRooms
              .filter((room, index, self) => 
                index === self.findIndex(r => r.id === room.id)
              )
              .map((room) => (
                <div 
                  key={room.id} // ÏõêÎûòÎåÄÎ°ú room.id ÏÇ¨Ïö© (Ï§ëÎ≥µÏùÄ ÏúÑÏóêÏÑú Ïù¥ÎØ∏ Ï†úÍ±∞)
                  className={styles.roomCard}
                  onClick={() => joinMusicRoom(room.id)}
                >
                  <div className={styles.roomHeader}>
                    <div className={styles.roomName}>üéµ {room.name || 'Unnamed Room'}</div>
                    <div className={styles.roomUsers}>
                      {room.userCount || 0}/{room.maxUsers || 10}
                    </div>
                  </div>
                  <div className={styles.roomDescription}>
                    {room.description || 'No description available'}
                  </div>
                  <div className={styles.roomTech}>
                    {room.tech?.join(' ‚Ä¢ ') || 'No technologies specified'}
                  </div>
                  <div className={styles.roomStatus}>
                    <span className={room.status === 'active' ? styles.active : styles.inactive}>
                      {room.status ? room.status.toUpperCase() : 'UNKNOWN'}
                    </span>
                  </div>
                </div>
              ))
          )}
        </div>
      </div>
    </div>
  );
}