const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const compression = require('compression');
const helmet = require('helmet');
const morgan = require('morgan');

// ===== EXPRESS Î∞è ÏÑúÎ≤Ñ ÏÑ§Ï†ï =====
const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
  cors: {
    origin: ["http://localhost:3000", "http://127.0.0.1:3000"],
    methods: ["GET", "POST"],
    credentials: true
  },
  transports: ['websocket', 'polling']
});

// ===== ÎØ∏Îì§Ïõ®Ïñ¥ ÏÑ§Ï†ï =====
app.use(helmet({ crossOriginEmbedderPolicy: false }));
app.use(compression());
app.use(morgan('combined'));
app.use(cors({
  origin: ["http://localhost:3000", "http://127.0.0.1:3000"],
  credentials: true
}));
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// ===== ÏóÖÎ°úÎìú Ìè¥Îçî ÏÉùÏÑ± =====
const uploadDirs = ['uploads/chat', 'uploads/music', 'uploads/voice'];
uploadDirs.forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
});

// ===== MULTER ÏÑ§Ï†ï =====
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    let type = 'voice';
    
    if (req.path.includes('/chat') || req.url.includes('/chat')) {
      type = 'chat';
    } else if (req.path.includes('/music') || req.url.includes('/music')) {
      type = 'music';
    } else if (req.path.includes('/voice') || req.url.includes('/voice')) {
      type = 'voice';
    }
    
    console.log(`üìÅ File destination: ${type} (from ${req.path})`);
    cb(null, `uploads/${type}/`);
  },
  filename: (req, file, cb) => {
    const timestamp = Date.now();
    const ext = path.extname(file.originalname);
    
    // ÌååÏùºÎ™ÖÏùÑ ÏïàÏ†ÑÌïòÍ≤å Ï≤òÎ¶¨ (ÌïúÍ∏Ä Î∞è ÌäπÏàòÎ¨∏Ïûê Ï≤òÎ¶¨)
    const originalName = path.basename(file.originalname, ext);
    const safeName = originalName
      .replace(/[^\w\s-Í∞Ä-Ìû£]/g, '') // ÏòÅÎ¨∏, Ïà´Ïûê, Í≥µÎ∞±, ÌïòÏù¥Ìîà, ÌïúÍ∏ÄÎßå ÌóàÏö©
      .replace(/\s+/g, '_') // Í≥µÎ∞±ÏùÑ Ïñ∏ÎçîÏä§ÏΩîÏñ¥Î°ú Î≥ÄÍ≤Ω
      .substring(0, 50); // Í∏∏Ïù¥ Ï†úÌïú
    
    const finalName = `${timestamp}_${safeName}${ext}`;
    console.log(`üìù Generated filename: ${file.originalname} -> ${finalName}`);
    
    cb(null, finalName);
  }
});

const upload = multer({
  storage: storage,
  limits: { fileSize: 50 * 1024 * 1024 },
  fileFilter: (req, file, cb) => {
    console.log('üîç File check:', {
      name: file.originalname,
      mime: file.mimetype,
      path: req.path
    });

    // ÏúÑÌóòÌïú ÌååÏùº ÌôïÏû•ÏûêÎßå Ï∞®Îã®
    const dangerousExtensions = /\.(exe|bat|cmd|scr|pif|com|vbs|jar)$/i;
    
    if (dangerousExtensions.test(file.originalname)) {
      console.error('‚ùå Dangerous file blocked:', file.originalname);
      return cb(new Error('Î≥¥ÏïàÏÉÅ ÏúÑÌóòÌïú ÌååÏùº ÌòïÏãùÏûÖÎãàÎã§.'));
    }
    
    // ÎÇòÎ®∏ÏßÄÎäî Î™®Îëê ÌóàÏö©
    console.log('‚úÖ File accepted:', file.originalname);
    return cb(null, true);
  }
});

// ===== Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•ÏÜå ÌÅ¥ÎûòÏä§ =====
class DataStore {
  constructor() {
    this.users = new Map();
    this.chatRooms = new Map();
    this.musicRooms = new Map();
    this.chatMessages = new Map();
    this.musicComments = new Map();
  }

  // ÏÇ¨Ïö©Ïûê Í¥ÄÎ¶¨
  addUser(socketId, user) {
    this.users.set(socketId, user);
  }

  removeUser(socketId) {
    this.users.delete(socketId);
  }

  getUser(socketId) {
    return this.users.get(socketId);
  }

  getAllUsers() {
    return Array.from(this.users.values());
  }

  // Ï±ÑÌåÖÎ£∏ Í¥ÄÎ¶¨
  createChatRoom(roomData) {
    const roomId = `chat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const room = {
      id: roomId,
      ...roomData,
      users: new Set(),
      messages: [],
      createdAt: new Date().toISOString(),
      type: 'chat'
    };
    
    this.chatRooms.set(roomId, room);
    return room;
  }

  getChatRoom(roomId) {
    return this.chatRooms.get(roomId);
  }

  getAllChatRooms() {
    return Array.from(this.chatRooms.values()).map(room => ({
      id: room.id,
      name: room.name,
      userCount: room.users.size,
      maxUsers: room.maxUsers,
      hasPassword: !!room.password,
      creator: room.creator,
      lastMessage: room.lastMessage || '',
      lastMessageTime: room.lastMessageTime || 0,
      type: 'chat'
    }));
  }

  joinChatRoom(roomId, userId, password = '') {
    const room = this.chatRooms.get(roomId);
    if (!room) return { success: false, message: 'Room not found' };
    
    if (room.password && room.password !== password) {
      return { success: false, message: 'Wrong password' };
    }
    
    if (room.users.size >= room.maxUsers) {
      return { success: false, message: 'Room is full' };
    }
    
    room.users.add(userId);
    return { success: true, room };
  }

  leaveChatRoom(roomId, userId) {
    const room = this.chatRooms.get(roomId);
    if (room) {
      room.users.delete(userId);
    }
  }

  // ÎÆ§ÏßÅÎ£∏ Í¥ÄÎ¶¨
  createMusicRoom(roomData) {
    const roomId = `music_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const room = {
      id: roomId,
      ...roomData,
      users: new Set(),
      currentTrack: null,
      isPlaying: false,
      createdAt: new Date().toISOString(),
      type: 'music'
    };
    
    this.musicRooms.set(roomId, room);
    return room;
  }

  getMusicRoom(roomId) {
    return this.musicRooms.get(roomId);
  }

  getAllMusicRooms() {
    return Array.from(this.musicRooms.values()).map(room => ({
      id: room.id,
      name: room.name,
      userCount: room.users.size,
      maxUsers: room.maxUsers,
      hasPassword: !!room.password,
      creator: room.creator,
      description: room.description || '',
      tech: room.tech || [],
      status: room.users.size > 0 ? 'active' : 'inactive'
    }));
  }

  joinMusicRoom(roomId, userId, password = '') {
    const room = this.musicRooms.get(roomId);
    if (!room) return { success: false, message: 'Room not found' };
    
    if (room.password && room.password !== password) {
      return { success: false, message: 'Wrong password' };
    }
    
    if (room.users.size >= room.maxUsers) {
      return { success: false, message: 'Room is full' };
    }
    
    room.users.add(userId);
    return { success: true, room };
  }

  leaveMusicRoom(roomId, userId) {
    const room = this.musicRooms.get(roomId);
    if (room) {
      room.users.delete(userId);
    }
  }

  // ÎÆ§ÏßÅ ÎåìÍ∏Ä Í¥ÄÎ¶¨
  addMusicComment(roomId, comment) {
    if (!this.musicComments.has(roomId)) {
      this.musicComments.set(roomId, []);
    }
    this.musicComments.get(roomId).push(comment);
  }

  getMusicComments(roomId) {
    return this.musicComments.get(roomId) || [];
  }
}

const dataStore = new DataStore();

// ===== API ÎùºÏö∞Ìä∏ =====
app.get('/', (req, res) => {
  res.json({
    status: 'success',
    message: 'VLYNK Server v3.0.0 - Professional Edition',
    timestamp: new Date().toISOString(),
    features: [
      'Namespaced Socket.IO (/chat, /project)',
      'Separated Chat & Music Rooms',
      'Professional File Upload System',
      'Real-time User Management'
    ]
  });
});

app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    uptime: process.uptime(),
    timestamp: new Date().toISOString(),
    memory: process.memoryUsage(),
    stats: {
      users: dataStore.getAllUsers().length,
      chatRooms: dataStore.chatRooms.size,
      musicRooms: dataStore.musicRooms.size
    }
  });
});

// ===== ÌååÏùº ÏóÖÎ°úÎìú API =====
app.post('/api/upload/chat', upload.single('file'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }

  const fileUrl = `/api/files/chat/${req.file.filename}`;
  res.json({
    success: true,
    file: {
      filename: req.file.filename,
      originalName: req.file.originalname,
      url: fileUrl,
      size: req.file.size,
      mimetype: req.file.mimetype,
      type: req.file.mimetype.startsWith('image/') ? 'image' : 
            req.file.mimetype.startsWith('audio/') ? 'audio' :
            req.file.mimetype.startsWith('video/') ? 'video' : 'file'
    }
  });
});

app.post('/api/upload/music', upload.single('music'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No music file uploaded' });
  }

  const fileUrl = `/api/files/music/${req.file.filename}`;
  console.log('üéµ Music file uploaded:', req.file.filename);
  
  res.json({
    success: true,
    file: {
      filename: req.file.filename,
      originalName: req.file.originalname,
      url: fileUrl,
      size: req.file.size,
      mimetype: req.file.mimetype
    }
  });
});

app.post('/api/upload/voice', upload.single('voice'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No voice file uploaded' });
  }

  const fileUrl = `/api/files/voice/${req.file.filename}`;
  res.json({
    success: true,
    file: {
      filename: req.file.filename,
      originalName: req.file.originalname,
      url: fileUrl,
      size: req.file.size,
      mimetype: req.file.mimetype
    }
  });
});

// ===== ÌååÏùº Ï†úÍ≥µ Î∞è Îã§Ïö¥Î°úÎìú (CORS Ìó§Îçî Ï∂îÍ∞Ä) =====
app.get('/api/files/:type/:filename', (req, res) => {
  const { type, filename } = req.params;
  const filePath = path.join(__dirname, 'uploads', type, filename);

  console.log('üìÅ File request:', filePath);

  if (!fs.existsSync(filePath)) {
    console.error('‚ùå File not found:', filePath);
    return res.status(404).json({ error: 'File not found' });
  }

  // CORS Ìó§Îçî Ï∂îÍ∞Ä
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Range');
  res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, DELETE');
  res.header('Access-Control-Expose-Headers', 'Content-Length, Content-Range, Accept-Ranges');
  
  // ÌååÏùº ÌÉÄÏûÖÏóê Îî∞Î•∏ Content-Type ÏÑ§Ï†ï
  const ext = path.extname(filename).toLowerCase();
  let contentType = 'application/octet-stream';
  
  switch(ext) {
    case '.mp3':
      contentType = 'audio/mpeg';
      break;
    case '.wav':
      contentType = 'audio/wav';
      break;
    case '.ogg':
      contentType = 'audio/ogg';
      break;
    case '.m4a':
      contentType = 'audio/mp4';
      break;
    case '.flac':
      contentType = 'audio/flac';
      break;
    case '.webm':
      contentType = 'audio/webm';
      break;
    case '.jpg':
    case '.jpeg':
      contentType = 'image/jpeg';
      break;
    case '.png':
      contentType = 'image/png';
      break;
    case '.gif':
      contentType = 'image/gif';
      break;
    case '.mp4':
      contentType = 'video/mp4';
      break;
    default:
      contentType = 'application/octet-stream';
  }
  
  res.header('Content-Type', contentType);
  res.header('Accept-Ranges', 'bytes');
  res.header('Cache-Control', 'public, max-age=3600');
  
  console.log('‚úÖ Serving file:', filename, 'as', contentType);
  res.sendFile(filePath);
});

// OPTIONS Ìï∏Îì§Îü¨ Ï∂îÍ∞Ä (CORS preflight)
app.options('/api/files/:type/:filename', (req, res) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Range');
  res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, DELETE');
  res.sendStatus(200);
});

app.get('/api/download/:type/:filename', (req, res) => {
  const { type, filename } = req.params;
  const filePath = path.join(__dirname, 'uploads', type, filename);

  if (!fs.existsSync(filePath)) {
    return res.status(404).json({ error: 'File not found' });
  }

  res.download(filePath);
});

// ===== SOCKET.IO ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î∂ÑÎ¶¨ =====

// üó®Ô∏è CHAT ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§
const chatNamespace = io.of('/chat');
chatNamespace.on('connection', (socket) => {
  console.log(`üó®Ô∏è Chat user connected: ${socket.id}`);

  // ÏÇ¨Ïö©Ïûê Î°úÍ∑∏Ïù∏
  socket.on('user:login', (userData) => {
    const user = {
      id: socket.id,
      username: userData.username,
      role: userData.role || 'MEMBER',
      namespace: 'chat'
    };
    
    dataStore.addUser(socket.id, user);
    socket.user = user;
    
    console.log(`üë§ Chat user logged in: ${user.username}`);
    socket.emit('user:login_success', { user, connectedUsers: dataStore.getAllUsers().length });
    
    // Î™®Îì† Ï±ÑÌåÖÎ£∏ Î™©Î°ù Ï†ÑÏÜ°
    socket.emit('rooms:list', dataStore.getAllChatRooms());
  });

  // Î£∏ ÏÉùÏÑ±
  socket.on('room:create', (roomData) => {
    if (!socket.user) return;
    
    const room = dataStore.createChatRoom({
      ...roomData,
      creator: socket.user.username
    });
    
    console.log(`üè† Chat room created: ${room.name} by ${socket.user.username}`);
    chatNamespace.emit('rooms:list', dataStore.getAllChatRooms());
    socket.emit('room:created', { room });
  });

  // Î£∏ Ï∞∏Ïó¨
  socket.on('room:join', (joinData) => {
    if (!socket.user) return;
    
    const result = dataStore.joinChatRoom(joinData.roomId, socket.id, joinData.password);
    if (result.success) {
      socket.join(joinData.roomId);
      socket.currentRoom = joinData.roomId;
      
      socket.emit('room:joined', { 
        room: result.room,
        messages: result.room.messages || []
      });
      
      socket.to(joinData.roomId).emit('chat:user_joined', {
        message: `${socket.user.username}ÎãòÏù¥ ÏûÖÏû•ÌñàÏäµÎãàÎã§.`,
        user: socket.user
      });
      
      chatNamespace.emit('rooms:list', dataStore.getAllChatRooms());
      console.log(`üö™ ${socket.user.username} joined chat room: ${result.room.name}`);
    } else {
      socket.emit('room:error', { message: result.message });
    }
  });

  // Î©îÏãúÏßÄ Ï†ÑÏÜ°
  socket.on('chat:message', (messageData) => {
    if (!socket.user || !socket.currentRoom) return;
    
    const room = dataStore.getChatRoom(socket.currentRoom);
    if (!room) return;
    
    const message = {
      id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      userId: socket.id,
      username: socket.user.username,
      message: messageData.message,
      timestamp: new Date().toISOString(),
      type: messageData.type || 'text',
      fileUrl: messageData.fileUrl,
      fileSize: messageData.fileSize
    };
    
    room.messages.push(message);
    room.lastMessage = messageData.message;
    room.lastMessageTime = Date.now();
    
    chatNamespace.to(socket.currentRoom).emit('chat:message', message);
    chatNamespace.emit('rooms:list', dataStore.getAllChatRooms());
  });

  // Ïó∞Í≤∞ Ìï¥Ï†ú
  socket.on('disconnect', () => {
    if (socket.user && socket.currentRoom) {
      dataStore.leaveChatRoom(socket.currentRoom, socket.id);
      socket.to(socket.currentRoom).emit('chat:user_left', {
        message: `${socket.user.username}ÎãòÏù¥ Ìá¥Ïû•ÌñàÏäµÎãàÎã§.`,
        user: socket.user
      });
      chatNamespace.emit('rooms:list', dataStore.getAllChatRooms());
    }
    
    if (socket.user) {
      dataStore.removeUser(socket.id);
    }
    
    console.log(`üó®Ô∏è Chat user disconnected: ${socket.id}`);
  });
});

// üéµ PROJECT ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§
const projectNamespace = io.of('/project');
projectNamespace.on('connection', (socket) => {
  console.log(`üéµ Project user connected: ${socket.id}`);

  // ÏÇ¨Ïö©Ïûê Î°úÍ∑∏Ïù∏
  socket.on('user:login', (userData) => {
    const user = {
      id: socket.id,
      username: userData.username,
      role: userData.role || 'MEMBER',
      namespace: 'project'
    };
    
    dataStore.addUser(socket.id, user);
    socket.user = user;
    
    console.log(`üë§ Project user logged in: ${user.username}`);
    socket.emit('user:login_success', { user, connectedUsers: dataStore.getAllUsers().length });
    
    // Î™®Îì† ÎÆ§ÏßÅÎ£∏ Î™©Î°ù Ï†ÑÏÜ°
    socket.emit('rooms:list', dataStore.getAllMusicRooms());
  });

  // Î£∏ ÏÉùÏÑ±
  socket.on('room:create', (roomData) => {
    if (!socket.user) return;
    
    const room = dataStore.createMusicRoom({
      ...roomData,
      creator: socket.user.username
    });
    
    console.log(`üéµ Music room created: ${room.name} by ${socket.user.username}`);
    projectNamespace.emit('rooms:list', dataStore.getAllMusicRooms());
    socket.emit('room:created', { room });
  });

  // Î£∏ Ï∞∏Ïó¨
  socket.on('room:join', (joinData) => {
    if (!socket.user) return;
    
    const result = dataStore.joinMusicRoom(joinData.roomId, socket.id, joinData.password);
    if (result.success) {
      socket.join(joinData.roomId);
      socket.currentRoom = joinData.roomId;
      
      socket.emit('music:room_joined', { 
        room: result.room,
        comments: dataStore.getMusicComments(joinData.roomId)
      });
      
      socket.to(joinData.roomId).emit('music:user_joined', {
        message: `${socket.user.username}ÎãòÏù¥ ÏûÖÏû•ÌñàÏäµÎãàÎã§.`,
        user: socket.user
      });
      
      projectNamespace.emit('rooms:list', dataStore.getAllMusicRooms());
      console.log(`üéµ ${socket.user.username} joined music room: ${result.room.name}`);
    } else {
      socket.emit('room:error', { message: result.message });
    }
  });

  // ÏùåÏïÖ ÏóÖÎ°úÎìú (Í∏∞Ï°¥ Ïù¥Î≤§Ìä∏Î™Ö Ïú†ÏßÄ)
  socket.on('music uploaded', (data) => {
    if (!socket.currentRoom) return;
    
    const room = dataStore.getMusicRoom(socket.currentRoom);
    if (room) {
      const track = {
        originalName: data.musicData.originalname,
        filename: data.musicData.filename,
        url: data.musicData.url,
        uploader: socket.user.username,
        uploadedAt: new Date().toISOString()
      };
      
      room.currentTrack = track;
      
      // Î£∏Ïùò Î™®Îì† ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏùåÏïÖ ÏóÖÎ°úÎìú ÏïåÎ¶º
      projectNamespace.to(socket.currentRoom).emit('music uploaded', {
        track: track,
        uploader: socket.user.username
      });
      
      console.log(`üéµ Music uploaded: ${data.musicData.originalname} by ${socket.user.username}`);
    }
  });

  // ÌîåÎ†àÏù¥Î∞± ÌÜ†Í∏Ä (Í∏∞Ï°¥ Ïù¥Î≤§Ìä∏Î™Ö Ïú†ÏßÄ)
  socket.on('toggle playback', (data) => {
    if (!socket.currentRoom) return;
    
    const room = dataStore.getMusicRoom(socket.currentRoom);
    if (room) {
      room.isPlaying = !room.isPlaying;
      socket.to(socket.currentRoom).emit('playback toggled', {
        isPlaying: room.isPlaying,
        user: socket.user.username
      });
      
      console.log(`üéµ Playback toggled by ${socket.user.username}: ${room.isPlaying}`);
    }
  });

  // ÏùåÏïÖ Ï±ÑÌåÖ (Í∏∞Ï°¥ Ïù¥Î≤§Ìä∏Î™Ö Ïú†ÏßÄ)
  socket.on('music chat message', (data) => {
    if (!socket.currentRoom) return;
    
    const comment = {
      id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      user: socket.user.username,
      message: data.message,
      timestamp: data.timestamp || 0,
      time: new Date().toISOString(),
      type: data.type || 'text',
      voiceUrl: data.voiceUrl
    };
    
    dataStore.addMusicComment(socket.currentRoom, comment);
    
    projectNamespace.to(socket.currentRoom).emit('music chat message', comment);
    console.log(`üí¨ Music comment from ${socket.user.username}: ${data.message}`);
  });

  // Ïó∞Í≤∞ Ìï¥Ï†ú
  socket.on('disconnect', () => {
    if (socket.user && socket.currentRoom) {
      dataStore.leaveMusicRoom(socket.currentRoom, socket.id);
      socket.to(socket.currentRoom).emit('music:user_left', {
        message: `${socket.user.username}ÎãòÏù¥ Ìá¥Ïû•ÌñàÏäµÎãàÎã§.`,
        user: socket.user
      });
      projectNamespace.emit('rooms:list', dataStore.getAllMusicRooms());
    }
    
    if (socket.user) {
      dataStore.removeUser(socket.id);
    }
    
    console.log(`üéµ Project user disconnected: ${socket.id}`);
  });
});

// ===== ÏóêÎü¨ Ìï∏Îì§ÎßÅ =====
app.use((error, req, res, next) => {
  if (error instanceof multer.MulterError) {
    if (error.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({ error: 'ÌååÏùº ÌÅ¨Í∏∞Í∞Ä ÎÑàÎ¨¥ ÌÅΩÎãàÎã§ (ÏµúÎåÄ 50MB)' });
    }
    return res.status(400).json({ error: 'ÌååÏùº ÏóÖÎ°úÎìú Ïò§Î•ò: ' + error.message });
  }
  
  if (error) {
    console.error('‚ùå General error:', error);
    return res.status(400).json({ error: error.message || 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' });
  }
  
  res.status(500).json({
    error: {
      message: 'Internal Server Error',
      status: 500,
      timestamp: new Date().toISOString()
    }
  });
});

app.use('*', (req, res) => {
  res.status(404).json({
    error: {
      message: 'Route not found',
      status: 404,
      path: req.originalUrl,
      timestamp: new Date().toISOString()
    }
  });
});

// ===== ÏÑúÎ≤Ñ ÏãúÏûë =====
const PORT = process.env.PORT || 3001;

server.listen(PORT, () => {
  console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           üöÄ VLYNK SERVER v3.0        ‚ïë
‚ïë          Professional Edition         ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  Port: ${PORT.toString().padEnd(31)} ‚ïë
‚ïë  Status: ‚úÖ Running                   ‚ïë
‚ïë  Chat Namespace: ‚úÖ /chat             ‚ïë
‚ïë  Project Namespace: ‚úÖ /project       ‚ïë
‚ïë  File Upload: ‚úÖ Ready                ‚ïë
‚ïë  CORS: ‚úÖ Configured                  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üéØ Namespaced Features:
   ‚Ä¢ /chat - Real-time Chat Rooms
   ‚Ä¢ /project - Music Collaboration Rooms
   ‚Ä¢ Professional File Upload System
   ‚Ä¢ Separated Data Management
   ‚Ä¢ Audio Streaming with CORS Support
   
üîó API Endpoints:
   ‚Ä¢ Main: http://localhost:${PORT}
   ‚Ä¢ Health: http://localhost:${PORT}/health
   ‚Ä¢ Chat Upload: POST /api/upload/chat
   ‚Ä¢ Music Upload: POST /api/upload/music
   ‚Ä¢ Voice Upload: POST /api/upload/voice
   ‚Ä¢ File Serving: GET /api/files/:type/:filename
  `);
});

// ===== Graceful Shutdown =====
process.on('SIGTERM', () => {
  console.log('üõë SIGTERM received, shutting down gracefully...');
  server.close(() => {
    console.log('‚úÖ Server closed');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('üõë SIGINT received, shutting down gracefully...');
  server.close(() => {
    console.log('‚úÖ Server closed');
    process.exit(0);
  });
});

module.exports = { app, server, io, dataStore };